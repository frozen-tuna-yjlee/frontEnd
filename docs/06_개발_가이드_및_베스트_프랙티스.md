# 개발 가이드 및 베스트 프랙티스

## 1. 코딩 스타일 가이드

### 1.1 TypeScript 사용 규칙

#### 타입 정의
```typescript
// ✅ 좋은 예: 명확한 인터페이스 정의
interface User {
  id: string;
  name: string;
  email: string;
  avatarUrl?: string; // 선택적 속성
}

// ❌ 나쁜 예: any 사용
function getUser(id: any): any {
  // ...
}
```

#### 함수 타입
```typescript
// ✅ 좋은 예: 명시적 타입
const handleClick = (event: React.MouseEvent<HTMLButtonElement>): void => {
  // ...
};

// ❌ 나쁜 예: 타입 생략
const handleClick = (event) => {
  // ...
};
```

---

### 1.2 React 컴포넌트 작성 규칙

#### 함수 컴포넌트 사용
```typescript
// ✅ 좋은 예: 함수 컴포넌트
const MyComponent: React.FC<Props> = ({ prop1, prop2 }) => {
  return <div>{prop1}</div>;
};

// ❌ 나쁜 예: 클래스 컴포넌트 (필요한 경우 제외)
class MyComponent extends React.Component {
  // ...
}
```

#### Props 인터페이스 정의
```typescript
// ✅ 좋은 예: Props 인터페이스 명시
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({ label, onClick, disabled = false }) => {
  return <button onClick={onClick} disabled={disabled}>{label}</button>;
};
```

---

### 1.3 네이밍 규칙

#### 파일명
- 컴포넌트: PascalCase (예: `NewsCard.tsx`)
- 유틸리티: camelCase (예: `formatDate.ts`)
- 상수: UPPER_SNAKE_CASE (예: `API_BASE_URL.ts`)

#### 변수명
```typescript
// ✅ 좋은 예: 명확한 이름
const userEmail = 'user@example.com';
const isLoggedIn = true;
const newsItems = [];

// ❌ 나쁜 예: 모호한 이름
const email = 'user@example.com';
const flag = true;
const items = [];
```

#### 함수명
```typescript
// ✅ 좋은 예: 동사로 시작
const handleSubmit = () => {};
const fetchUserData = () => {};
const validateEmail = () => {};

// ❌ 나쁜 예: 명확하지 않은 이름
const submit = () => {};
const data = () => {};
const check = () => {};
```

---

## 2. 컴포넌트 설계 원칙

### 2.1 단일 책임 원칙

```typescript
// ✅ 좋은 예: 하나의 역할만 수행
const NewsCard: React.FC<NewsCardProps> = ({ title, description }) => {
  return (
    <div>
      <h3>{title}</h3>
      <p>{description}</p>
    </div>
  );
};

// ❌ 나쁜 예: 여러 역할 수행
const NewsCard: React.FC<Props> = ({ title, description, user, onLike, onShare }) => {
  // 뉴스 표시 + 좋아요 + 공유 + 사용자 정보
  // 너무 많은 책임
};
```

---

### 2.2 재사용성

```typescript
// ✅ 좋은 예: 재사용 가능한 컴포넌트
interface CardProps {
  title: string;
  children: React.ReactNode;
  className?: string;
}

const Card: React.FC<CardProps> = ({ title, children, className }) => {
  return (
    <div className={`card ${className || ''}`}>
      <h3>{title}</h3>
      {children}
    </div>
  );
};

// 사용
<Card title="뉴스" className="news-card">
  <NewsContent />
</Card>
```

---

### 2.3 Props 설계

```typescript
// ✅ 좋은 예: 필수/선택 Props 명확히 구분
interface ButtonProps {
  label: string;           // 필수
  onClick: () => void;     // 필수
  variant?: 'primary' | 'secondary';  // 선택
  size?: 'small' | 'medium' | 'large'; // 선택
  disabled?: boolean;      // 선택
}

// 기본값 설정
const Button: React.FC<ButtonProps> = ({
  label,
  onClick,
  variant = 'primary',
  size = 'medium',
  disabled = false
}) => {
  // ...
};
```

---

## 3. 상태 관리

### 3.1 useState 사용

```typescript
// ✅ 좋은 예: 타입 명시
const [user, setUser] = useState<User | null>(null);
const [count, setCount] = useState<number>(0);
const [isLoading, setIsLoading] = useState<boolean>(false);

// ❌ 나쁜 예: 타입 추론에만 의존
const [user, setUser] = useState(null);
```

---

### 3.2 useEffect 사용

```typescript
// ✅ 좋은 예: 의존성 배열 명시
useEffect(() => {
  fetchData();
}, [userId]); // userId가 변경될 때만 실행

// ✅ 좋은 예: cleanup 함수
useEffect(() => {
  const timer = setInterval(() => {
    // ...
  }, 1000);

  return () => {
    clearInterval(timer);
  };
}, []);

// ❌ 나쁜 예: 의존성 배열 누락
useEffect(() => {
  fetchData();
}); // 매 렌더링마다 실행
```

---

### 3.3 Context API 사용

```typescript
// ✅ 좋은 예: Context와 Provider 분리
const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  
  const value = useMemo(() => ({
    user,
    login,
    logout
  }), [user]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextValue => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

---

## 4. API 호출 패턴

### 4.1 Axios 사용

```typescript
// ✅ 좋은 예: 에러 처리 포함
const fetchUserData = async (userId: string): Promise<User> => {
  try {
    const response = await axiosInstance.get(`/api/users/${userId}`);
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error('사용자를 찾을 수 없습니다.');
    }
    throw error;
  }
};

// ❌ 나쁜 예: 에러 처리 없음
const fetchUserData = async (userId: string) => {
  const response = await axiosInstance.get(`/api/users/${userId}`);
  return response.data;
};
```

---

### 4.2 커스텀 훅 사용

```typescript
// ✅ 좋은 예: API 호출을 커스텀 훅으로 분리
const useUserData = (userId: string) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsLoading(true);
        const data = await fetchUserData(userId);
        setUser(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, [userId]);

  return { user, isLoading, error };
};

// 사용
const MyComponent = () => {
  const { user, isLoading, error } = useUserData('123');
  
  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error}</div>;
  return <div>{user?.name}</div>;
};
```

---

## 5. 에러 처리

### 5.1 에러 바운더리

```typescript
// ErrorBoundary 컴포넌트 생성
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('에러 발생:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>에러가 발생했습니다.</div>;
    }

    return this.props.children;
  }
}

// 사용
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

---

### 5.2 API 에러 처리

```typescript
// ✅ 좋은 예: 구체적인 에러 처리
try {
  await login(userId, password);
} catch (error: any) {
  if (error.response?.status === 401) {
    setError('아이디 또는 비밀번호가 올바르지 않습니다.');
  } else if (error.response?.status === 500) {
    setError('서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
  } else {
    setError('로그인에 실패했습니다.');
  }
}
```

---

## 6. 성능 최적화

### 6.1 React.memo

```typescript
// ✅ 좋은 예: 불필요한 리렌더링 방지
const NewsCard = React.memo<NewsCardProps>(({ title, description }) => {
  return (
    <div>
      <h3>{title}</h3>
      <p>{description}</p>
    </div>
  );
});

// 또는 커스텀 비교 함수
const NewsCard = React.memo<NewsCardProps>(
  ({ title, description }) => {
    // ...
  },
  (prevProps, nextProps) => {
    return prevProps.title === nextProps.title &&
           prevProps.description === nextProps.description;
  }
);
```

---

### 6.2 useMemo와 useCallback

```typescript
// ✅ 좋은 예: 계산 비용이 큰 값 메모이제이션
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);

// ✅ 좋은 예: 함수 메모이제이션
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

// ❌ 나쁜 예: 불필요한 메모이제이션
const simpleValue = useMemo(() => {
  return data.length; // 간단한 계산은 메모이제이션 불필요
}, [data]);
```

---

### 6.3 코드 스플리팅

```typescript
// ✅ 좋은 예: 동적 임포트
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

---

## 7. 스타일링 가이드

### 7.1 Tailwind CSS 사용

```typescript
// ✅ 좋은 예: Tailwind 유틸리티 클래스
<div className="flex items-center justify-between p-4 bg-white rounded-lg shadow">
  <h2 className="text-2xl font-bold text-gray-800">제목</h2>
  <button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
    클릭
  </button>
</div>

// ❌ 나쁜 예: 인라인 스타일
<div style={{ display: 'flex', padding: '16px' }}>
  {/* ... */}
</div>
```

---

### 7.2 반응형 디자인

```typescript
// ✅ 좋은 예: Tailwind 반응형 클래스
<div className="
  grid 
  grid-cols-1 
  md:grid-cols-2 
  lg:grid-cols-3 
  gap-4
">
  {/* ... */}
</div>

// ✅ 좋은 예: 조건부 클래스
<div className={`
  ${isActive ? 'bg-blue-500' : 'bg-gray-200'}
  ${isDisabled ? 'opacity-50' : ''}
`}>
  {/* ... */}
</div>
```

---

### 7.3 CSS 모듈 (필요한 경우)

```typescript
// ✅ 좋은 예: CSS 모듈 사용
import styles from './Component.module.css';

const Component = () => {
  return <div className={styles.container}>내용</div>;
};
```

---

## 8. 테스트 전략

### 8.1 단위 테스트

```typescript
// 예시: React Testing Library 사용
import { render, screen } from '@testing-library/react';
import NewsCard from './NewsCard';

test('뉴스 카드가 제목과 설명을 표시한다', () => {
  render(
    <NewsCard
      title="테스트 제목"
      description="테스트 설명"
      source="테스트 출처"
      date="2025-01-15"
    />
  );

  expect(screen.getByText('테스트 제목')).toBeInTheDocument();
  expect(screen.getByText('테스트 설명')).toBeInTheDocument();
});
```

---

### 8.2 통합 테스트

```typescript
// 예시: 사용자 플로우 테스트
test('사용자가 로그인할 수 있다', async () => {
  render(<App />);
  
  const loginButton = screen.getByText('로그인');
  fireEvent.click(loginButton);
  
  const userIdInput = screen.getByPlaceholderText('아이디를 입력하세요');
  fireEvent.change(userIdInput, { target: { value: 'testuser' } });
  
  // ...
});
```

---

## 9. 코드 리뷰 체크리스트

### 9.1 코드 품질

- [ ] TypeScript 타입이 명확하게 정의되어 있는가?
- [ ] 함수와 변수명이 명확한가?
- [ ] 중복 코드가 없는가?
- [ ] 에러 처리가 적절한가?
- [ ] 주석이 필요한 부분에 주석이 있는가?

### 9.2 React 베스트 프랙티스

- [ ] 컴포넌트가 단일 책임을 가지는가?
- [ ] Props 인터페이스가 명확한가?
- [ ] useEffect의 의존성 배열이 올바른가?
- [ ] 불필요한 리렌더링이 없는가?
- [ ] 메모이제이션이 필요한 부분에 적용되었는가?

### 9.3 성능

- [ ] 불필요한 API 호출이 없는가?
- [ ] 이미지 최적화가 되어 있는가?
- [ ] 번들 크기가 적절한가?

---

## 10. Git 작업 흐름

### 10.1 브랜치 전략

```
main (프로덕션)
  └── develop (개발)
      └── feature/기능명 (기능 개발)
      └── bugfix/버그명 (버그 수정)
      └── hotfix/긴급수정명 (긴급 수정)
```

### 10.2 커밋 메시지 규칙

```
타입: 간단한 설명

상세 설명 (선택사항)

예시:
feat: 카카오 로그인 기능 추가
fix: 로그인 토큰 갱신 버그 수정
refactor: NewsCard 컴포넌트 리팩토링
docs: API 명세서 업데이트
```

**타입**:
- `feat`: 새로운 기능
- `fix`: 버그 수정
- `refactor`: 리팩토링
- `docs`: 문서 수정
- `style`: 코드 스타일 변경
- `test`: 테스트 추가/수정
- `chore`: 빌드 설정 등

---

## 11. 디버깅 팁

### 11.1 React DevTools

- 컴포넌트 트리 확인
- Props와 State 확인
- Profiler로 성능 분석

### 11.2 콘솔 로깅

```typescript
// ✅ 좋은 예: 의미 있는 로그
console.log('사용자 로그인 시도:', { userId, timestamp: new Date() });
console.error('로그인 실패:', error);

// ❌ 나쁜 예: 불필요한 로그
console.log('test');
console.log(data); // data가 무엇인지 불명확
```

### 11.3 디버거 사용

```typescript
// 브레이크포인트 설정
debugger;

// 조건부 디버깅
if (someCondition) {
  debugger;
}
```

---

## 12. 보안 고려사항

### 12.1 민감한 정보 보호

```typescript
// ❌ 나쁜 예: 하드코딩된 키
const apiKey = 'secret-key-12345';

// ✅ 좋은 예: 환경 변수 사용
const apiKey = import.meta.env.VITE_API_KEY;
```

### 12.2 XSS 방지

```typescript
// ✅ 좋은 예: React는 자동으로 이스케이프
<div>{userInput}</div>

// ❌ 나쁜 예: dangerouslySetInnerHTML 사용 시 주의
<div dangerouslySetInnerHTML={{ __html: userInput }} />
```

### 12.3 토큰 관리

```typescript
// ✅ 좋은 예: localStorage에만 저장 (httpOnly 쿠키 권장)
localStorage.setItem('accessToken', token);

// ❌ 나쁜 예: 메모리에만 저장 (새로고침 시 손실)
let token = '...';
```

---

## 13. 접근성 (A11y)

### 13.1 시맨틱 HTML

```typescript
// ✅ 좋은 예: 시맨틱 태그 사용
<header>
  <nav>
    <ul>
      <li><a href="/">홈</a></li>
    </ul>
  </nav>
</header>

// ❌ 나쁜 예: div 남용
<div className="header">
  <div className="nav">
    <div>홈</div>
  </div>
</div>
```

### 13.2 ARIA 속성

```typescript
// ✅ 좋은 예: ARIA 속성 사용
<button
  aria-label="메뉴 열기"
  aria-expanded={isOpen}
  onClick={handleClick}
>
  <i className="fas fa-bars"></i>
</button>
```

---

## 14. 문서화

### 14.1 주석 작성

```typescript
/**
 * 사용자 정보를 가져옵니다.
 * 
 * @param userId - 사용자 ID
 * @returns 사용자 정보 또는 null
 * @throws {Error} 사용자를 찾을 수 없을 때
 */
const fetchUser = async (userId: string): Promise<User | null> => {
  // ...
};
```

### 14.2 README 작성

- 프로젝트 개요
- 설치 방법
- 사용 방법
- 주요 기능 설명

---

## 15. 참고 자료

### 공식 문서
- [React 공식 문서](https://react.dev/)
- [TypeScript 핸드북](https://www.typescriptlang.org/docs/)
- [Vite 가이드](https://vitejs.dev/guide/)
- [Tailwind CSS 문서](https://tailwindcss.com/docs)

### 유용한 리소스
- [React 패턴](https://reactpatterns.com/)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Web.dev](https://web.dev/)

